# Notes for the exam

# Development methods

## Waterfall model

Not very flexible. It flows in one direction, downwards like a waterfall. 
The main concept here is that you split development into phases, and once a phase is done, you move on to the next phase.

In Royce's original waterfall model, the following phases are followed in order:
1. System and software requrements: captured in a product requirements document.
2. Analysis: resulting in models, schema and business rules.
3. Design: resulting in the software architecture.
4. Coding: the development, proving and integration of software.
5. Testing: the systematic discovery and debugging of defects.
6. Operations: the installation, migration, support and maintenance of complete systems.

### Supporting arguments

Time spent early in the software production cycle can reduce costs at later stages. For example, a problem found in the early stages (such as requirements specification) is cheaper to fix than the same bug found later on in the process (by a factor of 50 to 200).

It puts emphasis on documentation and models, as these to a large degree need to be present before coding starts.

The approach is also very structured and easy to wrap your head around. The teams focus is very clear as each phase has a distinct focus. 

It might also the more clear to the customer how far the product has come in to production by looking at which phase the development team is currently working in.

It is argued that the waterfall model can be suited to projects where requirements and scope are fixed, the product itself is firm and stable, and the technology is clearly understood.

### Criticism

The biggest flaw of the waterfall method is the fact that most customers usually don't really know what they want. The have a general idea, but that might quickly change as development moves forward. The waterfall method is very poor at adapting to such changing requirements.

## Fusion


## Rational Unified Process (RUP)

RUP is an iterative software development process framework.  It divides the development process into four distinct phases that each involve business modeling, analysis and design, implementation, testing, and deployment. The four phases are:
1. **inception** - The idea for the project is stated. The development team determines if the project is worth pursuing and what resources will be needed.
2. **Elaboration** - The project's architecture and required resources are further evaluated. Developers consider possible applications of the software and costs associated with the development.
3. **Construction** - The project is developed and completed. The software is designed, written, and tested.
4. **Transition** - The software is released to the public. Final adjustments or updates are made based on feedback from end users. 

The RUP development methodology provides a structured way for companies to envision create software programs. Since it provides a specific plan for each step of the development process, it helps prevent resources from being wasted and reduces unexpected development costs.

The Rational Unified Process is structured around six fundamental best-practices, which are so-named due to their common use throughout the inustry:


- **Develop Software Iteratively**: Encourages iterative development by locating and working on the high-risk elements within every phase of the software development life cycle.
- **Manage Requirements**: Describes how to organize and keep track of functionality requirements, documentation, tradeoffs and decisions, and business requirements.
- **Use Component-Based Architectures**: Emphasizes development that focuses on software components which are reusable through this project and, most importantly, within future projects.
- **Visually Model Software**: Based on the Unified Modeling Language (UML), the Rational Unified Processprovides the means to visually model software, including the components and their relationships with one another.
- **Verify Software Quality**: Assists with design, implementation, and evaluation of all manner of tests throughout the software development life cycle.
- **Control Changes to Software**: Describes how to track and manage all forms of change that will inevitably occur throughout development, in order to produce successful iterations from one build to the next.

